- Aumenta a 10,20 le keyword per paragrafo

- Rimuovi il metodo per il batchInsert e sostituiscilo con askServer... se possibile,
oppure modificalo in modo che prenda un array di oggetti
NO! serve farlo per ogni evidenziature, e dato che ne fai una alla volta...
e se invece uso un generatore, tipo yield in Python (se c'è in js...)

oppure metti un nuovo argomento a newAnnotation (però poi devo mettere una funzione
che visualizzi le annotazioni)

A sto punto semplicemente rinominala setAnnotationsVisible
se gli viene passato false chiama removeHighlightings!



Forse una soluzione migliore per la cosa di djenius sarebbe bloccare la
visualizzazione nel finally del promise che manda al server la nuova
annotazione. Ora, so che con un semplice if non funziona perché tale finally
viene chiamata dopo che l'user ha già riattivato la visualizzazione, quindi devo
implementarla sfruttando le proprietà delle closure. Nella funzione , prima di
fare defer, creo una nuova var e assegno il valore di quella globale, poi nel
finally faccio check su quella locale. In tal modo dovrebbe funzionare

- se homepage, seleziona la searchbar in automatico
(nota: questo disattiva lo scroll con le frecce, me ne sbatto?)

- trasferisci la parte di codice che seleziona gli span nei p in una funzione helper
in Djenius (tipo newSelectionHelper), in modo che sia standardizzato il metodo di
selezione che non usa setEndAfter. Input: DOM Element
NO! l'elemento dopo va rimosso! meglio esporre un metodo per cercare e selezionare
all'interno di un elemento le parole date in un array, con argomento per decidere
se selezionarle una volta sola o tutte le volte che compaiono. (Tale metodo riscrive
l'HTML dell'elemento passato)

- in loadWiki agisci su link e immagini PRIMA di appendere l'html a content_wiki!

- usare .find() è più veloce che aggiungere all query
- meno specifico a sinistra della query, più specifico a destra
- evita "... > *", usa .children()

- nelle GET manda i parametri nell'URL, no come json

- page Angola, section Geography